#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/boost/graph/graph_traits_Polyhedron_3.h>
#include <CGAL/IO/Polyhedron_iostream.h>
#include <CGAL/mesh_segmentation.h>
#include <CGAL/property_map.h>
#include <iostream>
#include <fstream>
#include <CGAL/boost/graph/graph_traits_Surface_mesh.h>
#include <CGAL/Polyhedron_items_with_id_3.h>

    typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
    typedef CGAL::Polyhedron_3<K, CGAL::Polyhedron_items_with_id_3>  Polyhedron;


    // Property map associating a facet with an integer as id to an
    // element in a vector stored internally
    template<class ValueType>
    struct Facet_with_id_pmap
        : public boost::put_get_helper<ValueType&,
                 Facet_with_id_pmap<ValueType> >
    {
        typedef Polyhedron::Facet_const_handle key_type;
        typedef ValueType value_type;
        typedef value_type& reference;
        typedef boost::lvalue_property_map_tag category;
        Facet_with_id_pmap(
          std::vector<ValueType>& internal_vector
        ) : internal_vector(internal_vector) { }
        reference operator[](key_type key) const
        { return internal_vector[key->id()]; }
    private:
        std::vector<ValueType>& internal_vector;
    };
int main()
{
    std::cout << "hi \n";


        // create and read Polyhedron
        Polyhedron mesh;
        std::ifstream input("/home/highschoolintern/Desktop/TestReconstruction2/testReconstruction_4slicesPhysical_reconstruction_isolatedRemoved_decimated.off");
        if ( !input || !(input >> mesh) || mesh.empty() ) {
          std::cerr << "Not a valid off file." << std::endl;
          return EXIT_FAILURE;
        }
        // assign id field for each facet
        std::size_t facet_id = 0;
        for(Polyhedron::Facet_iterator facet_it = mesh.facets_begin();
          facet_it != mesh.facets_end(); ++facet_it, ++facet_id) {
            facet_it->id() = facet_id;
        }
        // create a property-map for SDF values
        std::vector<double> sdf_values(mesh.size_of_facets());
        Facet_with_id_pmap<double> sdf_property_map(sdf_values);
        CGAL::sdf_values(mesh, sdf_property_map);
        // access SDF values (with constant-complexity)


        for(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();
          facet_it != mesh.facets_end(); ++facet_it) {
            std::cout << sdf_property_map[facet_it] << " ";
        }


        std::cout << std::endl;
        // create a property-map for segment-ids
        std::vector<std::size_t> segment_ids(mesh.size_of_facets());
        Facet_with_id_pmap<std::size_t> segment_property_map(segment_ids);
        CGAL::segmentation_from_sdf_values(mesh, sdf_property_map, segment_property_map);
        // access segment-ids (with constant-complexity)


        for(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();
          facet_it != mesh.facets_end(); ++facet_it) {
            std::cout << segment_property_map[facet_it] << " ";


        }
        std::cout << std::endl;


    /*typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::Point_3 Point_3;
typedef CGAL::Surface_mesh<Point_3> Mesh;
typedef boost::graph_traits<Mesh>::vertex_descriptor vertex_descriptor;
typedef boost::graph_traits<Mesh>::face_descriptor face_descriptor;
typedef boost::graph_traits<Mesh>::face_iterator face_iterator;


typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef CGAL::Polyhedron_3<Kernel> Polyhedron;
    Mesh mesh;
    std::ifstream input("/home/highschoolintern/Desktop/TestReconstruction2/testReconstruction_4slicesPhysical_reconstruction_isolatedRemoved_decimated.off");
       if ( !input || !(input >> mesh)) {
         std::cerr << "Not a valid off file." << std::endl;
         return EXIT_FAILURE;
       }


    typedef Mesh::Property_map<face_descriptor,double> Facet_double_map;
    Facet_double_map sdf_property_map;
    sdf_property_map = mesh.add_property_map<face_descriptor,double>("f:sdf").first;
    // compute SDF values
    // We can't use default parameters for number of rays, and cone angle
    // and the postprocessing
    CGAL::sdf_values(mesh, sdf_property_map, 2.0 / 3.0 * CGAL_PI, 25, true);
    // create a property-map for segment-ids
    typedef Mesh::Property_map<face_descriptor, std::size_t> Facet_int_map;
    Facet_int_map segment_property_map = mesh.add_property_map<face_descriptor,std::size_t>("f:sid").first;;
    // segment the mesh using default parameters for number of levels, and smoothing lambda
    // Any other scalar values can be used instead of using SDF values computed using the CGAL function
    std::size_t number_of_segments = CGAL::segmentation_from_sdf_values(mesh, sdf_property_map, segment_property_map);
    std::cout << "Number of segments: " << number_of_segments << std::endl;
    // print segment-ids
    face_iterator facet_it, fend;

    BOOST_FOREACH(face_descriptor fd, faces(mesh)){
        // ids are between [0, number_of_segments -1]
        std::cout << segment_property_map[fd] << " ";

    }

    std::cout << std::endl;
    // use 4 clusters in soft clustering
    const std::size_t number_of_clusters = 4;
    const double smoothing_lambda = 0.3;
    // importance of surface features, suggested to be in-between [0,1]
    // Note that we can use the same SDF values (sdf_property_map) over and over again for segmentation.
    // This feature is relevant for segmenting the mesh several times with different parameters.
    CGAL::segmentation_from_sdf_values(mesh, sdf_property_map, segment_property_map, number_of_clusters, smoothing_lambda); */





    // create and read Polyhedron
    /* Polyhedron mesh;
    std::ifstream input("/home/highschoolintern/Desktop/TestReconstruction2/testReconstruction_4slicesPhysical_reconstruction_isolatedRemoved_decimated.off");
    if ( !input || !(input >> mesh) || mesh.empty() ) {
      std::cerr << "Not a valid off file." << std::endl;
      return EXIT_FAILURE;
    }


    //
    // create a property-map for segment-ids
     typedef std::map<Polyhedron::Facet_const_handle, std::size_t> Facet_int_map;
    Facet_int_map internal_segment_map;
    std::cout << "initializing property map complete" << std::endl;
    boost::associative_property_map<Facet_int_map> segment_property_map(internal_segment_map);
    std::cout << "Boost library initialized" << std::endl;
    // calculate SDF values and segment the mesh using default parameters.
    std::size_t number_of_segments = CGAL::segmentation_via_sdf_values(mesh, segment_property_map);
    std::cout << "Number of segments: " << number_of_segments << std::endl;

    // print segment-ids
  for(Polyhedron::Facet_const_iterator facet_it = mesh.facets_begin();
        facet_it != mesh.facets_end(); ++facet_it) {
        std::cout << segment_property_map[facet_it] << " ";
    }
    std::cout << std::endl;

   std::cout<< "What is the time of this image?" << std::endl;
    int time;
    std::cin >> time >> std::endl;

    ofstream myfile;
      myfile.open ("GraphingVals.txt");
      myfile << time ;
        myfile.close();*/

return 0;
}

